#Bienvenidos al c√≥digo de Workapp, el bot para buscar trabajo y hablar con Workie, su asistente virtual. 
import telebot
import requests
import google.generativeai as genai
import os
import time
from telebot import types

# Configuraci√≥n API KEY Gemini y Telegram
try:
    os.environ["API_KEY"] = "AIzaSyCUmTcXHVi1PKGBcsP2Pye7OfWD1CEjcCI"
    genai.configure(api_key=os.environ["API_KEY"])
except Exception as e:
    print(f"Error al configurar la API de Gemini: {e}")
    exit()

# Configuraci√≥n de Gemini
try:
    model = genai.GenerativeModel('gemini-1.5-flash-latest')
except Exception as e:
    print(f"Error al crear el modelo de Gemini: {e}")
    exit()

# Token del bot de Telegram
TOKEN = "7972576195:AAFApKCt351YIzZzb3yjRkGCrqZVCGzAHrU"
bot = telebot.TeleBot(TOKEN)

# URL de la API de Remotive
API_URL = "https://remotive.com/api/remote-jobs"

import requests

# Diccionario de √°reas de trabajo y localidades disponibles para los botones
AREAS_DE_TRABAJO = [
    'Dise√±o', 'Ventas', 'Producto', 'Atenci√≥n al cliente', 'Marketing'
]

# Localidades que son v√°lidas seg√∫n la API de Remotive
LOCALIDADES = [
    'En todo el mundo', 'Estados Unidos', 'Inglaterra', 'Canada', 'Alemania', 'Francia'
]

# Variables para almacenar la selecci√≥n de b√∫squeda
seleccion_localidad = None
seleccion_area_trabajo = None

# Variables para almacenar los trabajos mostrados
trabajos_mostrados_totales = []  # Para almacenar todos los trabajos mostrados

# Historial de conversaci√≥n con Workie (m√°ximo 3 interacciones)
historial_conversacion = {}


# Funci√≥n que hace la b√∫squeda de empleos y muestra los primeros 5 resultados
def buscar_empleos(area_trabajo, localidad, mostrar_nuevos=True):
    global trabajos_mostrados_totales
    params = {
        'category':
        area_trabajo,  
        'location': localidad
    }

    try:
        print(params)
        response = requests.get(API_URL, params=params)
        print(response)
        response.raise_for_status(
        )  # Lanza un error si la respuesta no es exitosa (status 200)
        data = response.json()
        jobs = data.get('jobs', [])

        # Filtramos para mostrar trabajos que no hayan sido mostrados previamente
        if mostrar_nuevos:
            nuevos_trabajos = [
                job for job in jobs if job not in trabajos_mostrados_totales
            ]
        else:
            nuevos_trabajos = jobs

        if nuevos_trabajos:
            result = "¬°Perfecto! Aqu√≠ tienes 5 b√∫squedas activas:\n"
            for i, job in enumerate(nuevos_trabajos[:5]):
                job_type = ''
                if job['job_type'] == 'full_time':
                    job_type = 'Full Time'
                elif job['job_type'] == 'part_time':
                    job_type = 'Part Time'
                elif job['job_type'] == 'contract':
                    job_type = 'Contrato'
                elif job['job_type'] == 'internship':
                    job_type = 'Pasantia'
                salary = job['salary'] if job['salary'] else "Sin especificar"
                result += f"{i + 1}. ‚ú® T√≠tulo: {job['title']}\n"
                result += f"   üëâ Empresa: {job['company_name']}\n"
                result += f"   üí∏ Salario: {salary}\n"
                result += f"   üìç Tipo de trabajo: {job_type}\n"
                result += f"   üîó Enlace: {job['url']}\n"
                result += "-" * 5 + "\n"
            # Actualizamos la lista de trabajos mostrados
            trabajos_mostrados_totales.extend(nuevos_trabajos[:5])
            return result
        else:
            return "No se encontraron nuevos empleos para esta b√∫squeda.\n"
    except requests.exceptions.RequestException as e:
        print(f"Error al hacer la solicitud a la API de Remotive: {e}")
        return "Hubo un error al conectar con la API de empleos. Intenta de nuevo.\n"


# Funci√≥n que muestra las opciones despu√©s de una respuesta de Workie
def mostrar_opciones_workie(message):
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True,
                                       one_time_keyboard=True)
    markup.add(types.KeyboardButton("Seguir hablando con Workie ü§ñ"))
    markup.add(types.KeyboardButton("Realizar nueva b√∫squeda üí°"))
    markup.add(types.KeyboardButton("Cerrar Workapp üëã"))

    bot.send_message(message.chat.id,
                     "¬øQu√© te gustar√≠a hacer ahora?",
                     reply_markup=markup)

    # Registrar el pr√≥ximo paso para manejar la opci√≥n seleccionada
    bot.register_next_step_handler(message, manejar_opciones_workie)


def manejar_opciones_workie(message):
    global seleccion_localidad, seleccion_area_trabajo

    if message.text == "Seguir hablando con Workie ü§ñ":
        # Continuar la conversaci√≥n con Workie
        bot.send_message(message.chat.id,
                         "¬°Genial! ¬øQu√© m√°s te gustar√≠a saber?")
        bot.register_next_step_handler(message, procesar_pregunta_workie)

    elif message.text == "Realizar nueva b√∫squeda üí°":
        # Volver a empezar la b√∫squeda, mostrar las localidades


        # Teclado de localidades para elegir nuevamente
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True,
                                           one_time_keyboard=True)
        localidad_buttons = [
            types.KeyboardButton(localidad) for localidad in LOCALIDADES
        ]
        markup.add(*localidad_buttons)

        bot.send_message(message.chat.id,"¬°Qu√© bueno! Vamos a empezar desde cero. ¬øDesde qu√© localidad te gustar√≠a trabajar?",

                         reply_markup=markup)

        # Registrar el siguiente paso para manejar la selecci√≥n de localidad
        bot.register_next_step_handler(message, handle_localidad_selection)

    elif message.text == "Cerrar Workapp üëã":
        bot.send_message(message.chat.id,
                         "Gracias por usar WorkApp üíõ. ¬°Te esperamos para continuar tu b√∫squeda laboral!")
    else:
        bot.send_message(
            message.chat.id,
            "No entend√≠ tu respuesta. Por favor, selecciona una opci√≥n de la botonera."
        )
        mostrar_opciones_workie(message)


# Funci√≥n que muestra las opciones de b√∫squeda despu√©s de obtener resultados de trabajos
def mostrar_opciones(message):
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True,
                                       one_time_keyboard=True)
    markup.add(types.KeyboardButton("Hablar con Workie ü§ñ"))
    markup.add(types.KeyboardButton("Buscar m√°s empleos üîç"))
    markup.add(types.KeyboardButton("Realizar una b√∫squeda nueva üí°"))
    markup.add(types.KeyboardButton("Cerrar Workapp üëã"))

    bot.send_message(message.chat.id,
                     "¬øQu√© te gustar√≠a hacer ahora? ü§î",
                     reply_markup=markup)


# Funci√≥n para interactuar con Gemini (con reintentos y manejo de tiempo)
def hablar_con_workie(pregunta, usuario_id):
    try:
        if usuario_id not in historial_conversacion:
            historial_conversacion[usuario_id] = []

        # Limitar el historial a 3 interacciones
        if len(historial_conversacion[usuario_id]) >= 3:
            historial_conversacion[usuario_id].pop(0)

        # A√±adir la pregunta al historial
        historial_conversacion[usuario_id].append(f"Usuario: {pregunta}")

        # Contexto para la conversaci√≥n
        contexto = "\n".join(historial_conversacion[usuario_id])

        # Intentar obtener la respuesta de Gemini con un l√≠mite de tiempo
        timeout = 120  # Tiempo m√°ximo de espera en segundos (2 minutos)
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                respuesta = model.generate_content(contexto)
                # A√±adir la respuesta de Workie al historial
                historial_conversacion[usuario_id].append(
                    f"Workie: {respuesta.text}")
                return respuesta.text
            except Exception as e:
                print(f"Error al interactuar con Gemini: {e}")
                time.sleep(10)  # Intentar nuevamente despu√©s de 10 segundos
        # Si no se recibe respuesta en el tiempo l√≠mite
        return "Lo siento, parece que Workie est√° teniendo problemas para responder. Intenta de nuevo m√°s tarde. üïí"
    except Exception as e:
        print(f"Error al generar contenido con Gemini: {e}")
        return "Hubo un error al interactuar con Workie. Intenta de nuevo m√°s tarde. üòû"


# Funci√≥n que maneja el comando /start y muestra los botones de selecci√≥n de localidad
@bot.message_handler(commands=['start'])
def enviar_bienvenida(message):
    # Teclado con botones de localidades
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True,
                                       one_time_keyboard=True)
    localidad_buttons = [
        types.KeyboardButton(localidad) for localidad in LOCALIDADES
    ]
    markup.add(*localidad_buttons)

    bot.send_message(
        message.chat.id,
        "¬°Te damos la bienvenida a WorkApp!üíõ El bot que te ayuda con tu b√∫squeda de trabajo.ü§ì Para empezar, elige desde qu√© localidad quieres trabajar",
        reply_markup=markup)

    # Guardamos el paso actual (localidad) para usarlo en la siguiente fase
    bot.register_next_step_handler(message, handle_localidad_selection)


# Funci√≥n que maneja la selecci√≥n de localidad
def handle_localidad_selection(message):
    global seleccion_localidad
    seleccion_localidad = message.text

    # Teclado con botones de √°reas de trabajo
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True,
                                       one_time_keyboard=True)
    area_buttons = [types.KeyboardButton(area) for area in AREAS_DE_TRABAJO]
    markup.add(*area_buttons)

    bot.send_message(
        message.chat.id,
        f"¬°Genial! Te mostraremos empleos que est√©n habilitados para trabajar desde {seleccion_localidad}. Ahora, ¬øen qu√© √°rea quieres trabajar?",
        reply_markup=markup)

    # Guardamos la localidad seleccionada para usarla despu√©s
    bot.register_next_step_handler(message, handle_area_selection)


# Funci√≥n que maneja la selecci√≥n de √°rea de trabajo
def handle_area_selection(message):
    global seleccion_area_trabajo
    seleccion_area_trabajo = message.text

    # Realizar la b√∫squeda de empleos con la localidad y el √°rea de trabajo seleccionados
    result = buscar_empleos(seleccion_area_trabajo, seleccion_localidad)
    bot.send_message(message.chat.id, result)

    # Mostrar opciones para continuar la conversaci√≥n
    mostrar_opciones(message)


# Funci√≥n que maneja las opciones seleccionadas por el usuario
@bot.message_handler(func=lambda message: message.text in [
    "Hablar con Workie ü§ñ", "Buscar m√°s empleos üîç",
    "Realizar una b√∫squeda nueva üí°", "Cerrar Workapp üëã"
])
def manejar_opciones(message):
    global seleccion_localidad, seleccion_area_trabajo  # Asegurarnos de que las variables sean globales

    if message.text == "Hablar con Workie ü§ñ":
        # Iniciar conversaci√≥n con Workie
        bot.send_message(
            message.chat.id,
            "¬°Hola, soy Workie!ü§ñ La IA que te acompa√±ar√° en tu b√∫squeda laboral, ¬øen qu√© puedo ayudarte hoy?"
        )
        bot.register_next_step_handler(message, procesar_pregunta_workie)

    elif message.text == "Buscar m√°s empleos üîç":
        # Muestra otros 5 trabajos con la misma b√∫squeda, sin repetir los ya mostrados anteriormente
        result = buscar_empleos(seleccion_area_trabajo,
                                seleccion_localidad,
                                mostrar_nuevos=True)
        bot.send_message(message.chat.id, result)

        # Muestra opciones nuevamente
        mostrar_opciones(message)

    elif message.text == "Realizar una b√∫squeda nueva üí°":
        # Volver a empezar la b√∫squeda, mostrar las localidades

        # Teclado de localidades para elegir nuevamente
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True,
                                           one_time_keyboard=True)
        localidad_buttons = [
            types.KeyboardButton(localidad) for localidad in LOCALIDADES
        ]
        markup.add(*localidad_buttons)

        bot.send_message(message.chat.id,"¬°Qu√© bueno! Vamos a empezar desde cero. ¬øDesde qu√© localidad te gustar√≠a trabajar?",

                         reply_markup=markup)


        # Registrar el siguiente paso para manejar la selecci√≥n de localidad
        bot.register_next_step_handler(message, handle_localidad_selection)

    elif message.text == "Cerrar Workapp üëã":
        # Finalizar la conversaci√≥n
        bot.send_message(
            message.chat.id,
            "Qu√© l√°stima que tengamos que despedirnos.ü•∫ Gracias por usar WorkApp üíõ Te esperamos para seguir acompa√±√°ndote en tu b√∫squeda laboral. ¬°Hasta pronto!üëã"
        )
        return


# Funci√≥n para procesar preguntas a Workie (Gemini)
def procesar_pregunta_workie(message):
    pregunta = message.text
    respuesta = hablar_con_workie(pregunta, message.chat.id)
    bot.send_message(message.chat.id, respuesta)

    # Mostrar opciones para seguir conversando o finalizar
    mostrar_opciones_workie(message)


# Funci√≥n que maneja la opci√≥n de seguir hablando con Workie
@bot.message_handler(
    func=lambda message: message.text == "Seguir hablando con Workie ü§ñ")
def seguir_hablando_con_workie(message):
    # Responder con la frase de continuaci√≥n
    bot.send_message(message.chat.id,
                     "¬°Es una buena elecci√≥n! ¬øEn qu√© m√°s te puedo ayudar? ü§î")
    bot.register_next_step_handler(message, procesar_pregunta_workie)


# Inicia el bot
try:
    print("Iniciando bot de Telegram...")
    bot.polling()
except Exception as e:
    print(f"Error al iniciar el bot: {e}")
